---
title: "{dm} and databases"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{{dm} and databases}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
fansi::set_knit_hooks(knitr::knit_hooks)
options(crayon.enabled = TRUE, width = 75, cli.width = 75)

knit_print.grViz <- function(x, ...) {
  x %>% 
    DiagrammeRsvg::export_svg() %>% 
    c("`````{=html}\n", ., "\n`````\n") %>% 
    knitr::asis_output()
}
```

{dm} is at its most powerful when you use it with databases
This article shows you how to get your {dm} objects to a database, how to set key constraints and how to get tables from databases to your local machine. 

Integration with {dbplyr} workflows on MSSQL and Postgres DBMS are easy as pie — full support for more databases will follow in future versions.

# Setting up the example

In order to work with a databases, you first need to connect to one.
We'll use a local Postgres database for this.

This requires you to have the PostgreSQL driver installed and activated (see install guides for [Mac OS X](https://www.robinwieruch.de/postgres-sql-macos-setup/), [Ubuntu 18.04](https://www.digitalocean.com/community/tutorials/how-to-install-and-use-postgresql-on-ubuntu-18-04), [Windows](https://www.microfocus.com/documentation/idol/IDOL_12_0/MediaServer/Guides/html/English/Content/Getting_Started/Configure/_TRN_Set_up_PostgreSQL.htm)). Also see this [Stackoverflow question](https://stackoverflow.com/questions/17633422/psql-fatal-database-user-does-not-exist) if you get the error `psql: FATAL: database “<user>” does not exist`. 

## Establishing a Connection With a Postgres Database

First, we'll establish a connection with your default local Postgres database. 
We'll do so using {DBI}:

```{r message=FALSE}
library(dm)
library(DBI)
library(dplyr)

con <- dbConnect(RPostgres::Postgres())
```

To check if any tables are already in your database, use `DBI::dbListTables()` on the connection object:
```{r}
dbListTables(con)
```

If tables `r cdm_nycflights13() %>% cdm_get_tables() %>% attr("names")` are already inside your database, delete them if you wish to use `cdm_copy_to()` with the example below, using `DBI::dbRemoveTable()`.

If you wish to delete all tables inside the database, you may also try `dbListTables(con) %>% purrr::map(dbRemoveTable, conn = con)`.

If you receive an error message saying you cannot delete a table because other objects depend on them, run:

```{r}
dbListTables(con) %>%
  purrr::map(~ DBI::dbExecute(
    conn = con,
    paste("DROP TABLE", .x, "CASCADE")
  ))
```

This removes all tables and those that depend on them.

## Getting {dm} Objects to Databases 

In this example, we copy the built-in example {dm} object `cdm_nycflights13()` to our example database. 
You can do so using `cdm_copy_to()`:

```{r}
remote_dm <- cdm_copy_to(
  con, 
  dm = cdm_nycflights13(), 
  set_key_constraints = FALSE,
  )
```

Make sure that you allocate your function call to an object to work with later.
This is necessary to work with the server later on — for example when you with to use `collect()`, as described below.

If you now call up the object `con` now, you will notice that the tables are now inside the database:

```{r}
RPostgres::dbListTables(con)
```

You'd notice the same thing by calling up the {dm} object you've assigned the function call to:

```{r}
remote_dm
```


## Setting Key Constraints on the Database

{dm} supports setting key constraints on the database for MSSQL and Postgres DBMS.
This means, the {dm} object's local key constraints (information you've provided to {dm} about primary keys and foreign keys) is transferred and applied to the database.

The database will thus be aware about information such as:
- whether a certain column is a primary key
- if a column type cannot be NULL
- if a certain column serves as a foreign key to other tables

This means: Make sure you include the option `set_key_constraints = FALSE` in your function call if an operation violates foreign key restraints, as it does in our example object above.
This is necessary when working with Postgres or MSSQL databases, otherwise your attempt will fail with an error message such as:

```
Error in result_create(conn@ptr, statement) : 
  Failed to fetch row: ERROR:  insert or update on table "flights" violates foreign key constraint "flights_tailnum_fkey"
DETAIL:  Key (tailnum)=(N3ALAA) is not present in table "planes".
```
When you use DBMS other than the latter two, such as SQLite, you're currently good to go using the default `cdm_copy_to()` option regarding `set_key_constraints`, as {dm} does not yet support setting key constraints yet for those DBMS.
<!-- As a consequence, {dm} does not execute the checks it would on the former two DBMS. -->

# Getting Tables from Databases

To retrieve {dm} objects from databases, {dm} offers two ways: `cdm_learn_from_db()` and `collect()`, a method for {dplyr}.

## `cdm_learn_from_db()`

`cdm_learn_from_db()` offers a first way to retrieve tables.
As opposed to the second, that is `collect()`, it 

```{r}
remote_src <- dm:::src_from_src_or_con(con)
db_learned <- remote_src  %>% 
  cdm_learn_from_db()

dplyr::src_postgres() %>%
  cdm_learn_from_db()

con %>% 
  cdm_learn_from_db()

remote_dm %>% 
  cdm_learn_from_db()
```

## `collect()`

`collect()` provides a method to retrieve tables from a database and saves them a {dm} object.

Again, we'll use the object above, as the `collect()` method will not work on your `con` object.

```{r}

remote_dm %>% 
  collect()

con %>% 
  collect()
```
